/*
 * $Id$
 */

#ifdef LINUX
#include <termios.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include <sqlenv.h>
#include <sqlutil.h>
#include <db2ApiDf.h>
#include <malloc.h>
#ifdef WIN32
#include <conio.h>
#endif
#include <ctype.h>
#include "utilemb.h"
#include "php_md5.h"

#define	RELEASE	"1.3"
#define REVISION "$Revision$"

int DataExport(char *, char *);
int DataImport(char *);

EXEC SQL INCLUDE SQLCA;

int main(int argc, char *argv[]) {


   EXEC SQL BEGIN DECLARE SECTION;
           char reguser[32];
           char regpwd[32];
           char user[32];			// var for actual user
           char pwd[34];			// host var for hashed pwd in pwdsafe.pwdlogin
           short admin;				// host var, if user is admin -> allow register new users
           short there;				// host var to check if tables are there
           char account[32];
           char userid[32];
           char password[32];
           char description[64];
           char haccount[32];
		   char huserid[32];
		   char hpassword[32];
           char hdescription[64];
           char enc_pwd[32];		// pwd entered
           char enc_pwd2[33];		// md5 hashed pwd
           char acc[32];			// host var for where clause
           char ts[32];
           short int tsind;			// indicator var for ts

           char uid[9];				// connection vars
           char passwd[19];
           char db[19];


   EXEC SQL END DECLARE SECTION;

#ifdef LINUX
   struct termios initialrsettings, newrsettings;
#endif

   int numsel = 0;					// menue var
   char numselh[10];				// menue help var
   struct sqlca sqlca;				// sqlca structure
   int ch, i = 0;					// vars for enc_pwd input
   char *temp_pwd;					// temp var for php_md5 func
   int del, upd;			    	// delete and update var (y/n)
   FILE *fp;						// filepointer fp
   char filename[255];				// var for filename
   char line[1024];					// buffer for read line
   char *pstr;

   unsigned int maxsel;

   // init connection vars

   db[0] = '\0';
   uid[0] = '\0';
   passwd[0] = '\0';

   switch( argc )
   {
	   case 2:
	      strcpy (db, argv[1]);
	      EXEC SQL CONNECT TO :db;
	      EMB_SQL_CHECK("CONNECT TO DB");
	      break;
	   case 4:
	      strcpy (db, argv[1]);
		  strcpy (uid, argv[2]);
		  strcpy (passwd, argv[3]);
		  EXEC SQL CONNECT TO :db USER :uid USING :passwd;
          EMB_SQL_CHECK("CONNECT TO DB");
          break;
       default:
          printf ("\nUSAGE: %s database [userid passwd]\n\n", argv[0]);
          return 1;
          break;
   }


   user[0] = '\0';
   pwd[0] = '\0';
   printf( "\nUser: ");
   fscanf( stdin, "%s", user );
   //fgets( user, 32, stdin );
   printf( "\nPlease enter the encryption password: " );

#ifdef WIN32
   do
      {
         ch = _getch();
         switch( ch )
         {
   		     case 8:
   		        if( i != 0 )
   		        {
   		    	   i=i-1;
   		    	   printf( "d" );
   		    	}
   		        break;
   		     case 13:
   		        break;
   		     default:
   		        enc_pwd[i++] = ch;
   		        printf( "*" );
   		        break;
   	     }
      } while( ch != '\r' );

   enc_pwd[i] = '\0';
#endif

#ifdef LINUX
   enc_pwd[0] = '\0';
   tcgetattr( fileno(stdin), &initialrsettings );
   newrsettings = initialrsettings;
   newrsettings.c_lflag &= ~ECHO;
   tcsetattr( fileno(stdin), TCSAFLUSH, &newrsettings );
   fscanf( stdin, "%s", enc_pwd );
   //fgets( enc_pwd, 32, stdin );
   tcsetattr( fileno(stdin), TCSANOW, &initialrsettings );
#endif

   temp_pwd = php_md5( enc_pwd );
   enc_pwd2[0] = '\0';
   strcpy( enc_pwd2, temp_pwd );
   free( temp_pwd );

   //printf( "\n%s\n%s\n", user, enc_pwd2 );  // debug

   EXEC SQL SELECT pwd, admin INTO :pwd, :admin
       FROM pwdsafe.pwdlogin
       WHERE usr = :user;

   //printf( "\n%s\n%s-\n%s-\n", user, enc_pwd2, pwd );  // debug

   if( sqlca.sqlcode == 100 )
   {
	   printf( "\n\nUser not found.\n" );
	   EXEC SQL CONNECT RESET;
       EMB_SQL_CHECK("CONNECT RESET");
	   return 1;
   }
   EMB_SQL_CHECK("SELECT");


   if( strcmp( pwd, enc_pwd2 ) != 0)
   {
	   printf( "\n\nUser / Password do not match.\n" );
	   EXEC SQL CONNECT RESET;
       EMB_SQL_CHECK("CONNECT RESET");
	   return 1;
   }

   printf("\n\n");
   printf("PwdSafe Application v%s (%s)\n",RELEASE,REVISION);

   do
      {
         numsel = 0;
         printf("\n\n");
         printf("************************************\n");
         printf(" 1 - Add entry\n");
         printf(" 2 - Search (fuzzy)\n");
         printf(" 3 - Search (exact)\n");
         printf(" 4 - Update Entry\n");
         printf(" 5 - Delete Entry\n");
         printf(" 6 - List all entries\n");
         printf(" 7 - Print all entries to .csv file\n" );
         printf(" 8 - Print all entries to file\n" );
         printf(" 9 - Change login password\n" );
         printf("10 - Export for sync\n" );
         printf("11 - Import and sync\n" );
         if( admin > 0 )
         {
            printf("12 - Register new user\n" );
         }
         printf("\n   Enter 0 to exit.\n");
         printf("************************************\n");

         printf("==> ");

         fflush(stdin);
         fscanf(stdin, "%d", &numsel);
         /*
         fgets( numselh, 10, stdin );
         numsel = atoi( numselh );
         if( numsel == 0 )
            numsel = -1;
         */
         maxsel = 11;			// Max menue sections
         if( admin > 0 )
         {
			 maxsel++;
		 }
         if (numsel < 0 || numsel > maxsel)
            printf("\nInvalid selection. Please try again.\n");
         else
            if (numsel != 0)
            {
                switch (numsel)
				   {
				      // Search (exact)
				      case 3:
				          printf( "\nWhich account: " );
				          acc[0] = '\0';
						  fscanf( stdin, "%s", acc );

						  account[0] = '\0';
						  userid[0] = '\0';
						  password[0] = '\0';
						  description[0] = '\0';

						  EXEC SQL SELECT account, userid, decrypt_char(password, :enc_pwd), description INTO :account, :userid, :password, :description
						              FROM pwdsafe.pwdlist
						              WHERE account = :acc AND usr = :user;

						  switch( sqlca.sqlcode )
						  {
							  case 0:
							   		printf( "\nAccount    : %s", account );
						  			printf( "\nUserid     : %s", userid );
						  			printf( "\nPassword   : %s", password );
   						 			printf( "\nDescription: %s", description );
   						 			break;
   						 	  case 100:
   						 	  		printf( "\nAccount not found." );
   						 	  		break;
   						 	  case -20144:
   						 	  case -20145:
   						 	  		printf( "\nWrong decryption password.");
   						 			EXEC SQL ROLLBACK;
   						 			return 1;
   						 			break;
   						 	  default:
   						 	  		EMB_SQL_CHECK("SELECT statement");
   						 	  		break;
						  }

   						  break;


					  // Search (fuzzy)
					  case 2:
					      printf( "\nWhich account: " );
					      acc[0] = '\0';
					      fflush(stdin);
						  //fgets( acc, 32, stdin );
						  fscanf( stdin, "%s", acc );

						  account[0] = '\0';
						  userid[0] = '\0';
						  password[0] = '\0';
						  description[0] = '\0';


						  EXEC SQL DECLARE c2 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description
						              FROM pwdsafe.pwdlist
						          WHERE usr = :user AND ucase(account) LIKE ucase('%' concat :acc concat '%')
						          ORDER BY account;

/*
						  EXEC SQL DECLARE c2 CURSOR FOR
						  		  SELECT account, userid, decrypt_char(password, :enc_pwd), description
						  			  FROM pwdsafe.pwdlist
						  		  WHERE usr = :user AND account LIKE ':acc'
						          ORDER BY account;
*/
						  EXEC SQL OPEN c2;
					      EMB_SQL_CHECK("OPEN CURSOR");

					      i=0;

					      do {
					         EXEC SQL FETCH c2 INTO :account, :userid, :password, :description;

					         if (SQLCODE != 0) break;

					         printf( "\nAccount    : %s", account );
							 printf( "\nUserid     : %s", userid );
							 printf( "\nPassword   : %s", password );
   						 	 printf( "\nDescription: %s", description );
   						 	 printf( "\n" );
   						 	 i++;
					      } while ( 1 );


					      switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	  		printf( "\nWrong decryption password.");
						   			EXEC SQL ROLLBACK;
						   			return 1;
						   			break;
						   	  case 100:
							     	if( i == 0 )
							     	    printf( "\nAccount not found." );
   						 	  		break;
						   	  default:
						   	  		break;
						  }

					      EXEC SQL CLOSE c2;
                          EMB_SQL_CHECK("CLOSE CURSOR");

                          break;


   					  // List all entries
   					  case 6:
   					      EXEC SQL DECLARE c1 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description
						              FROM pwdsafe.pwdlist
						          WHERE usr = :user
						          ORDER BY account;

						  EXEC SQL OPEN c1;
					      EMB_SQL_CHECK("OPEN CURSOR");

					      do {
					         EXEC SQL FETCH c1 INTO :account, :userid, :password, :description;

					         if (SQLCODE != 0) break;

					         printf( "\nAccount    : %s", account );
							 printf( "\nUserid     : %s", userid );
							 printf( "\nPassword   : %s", password );
   						 	 printf( "\nDescription: %s", description );
   						 	 printf( "\n" );
					      } while ( 1 );


					      switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	  		printf( "\nWrong decryption password.");
						   			EXEC SQL ROLLBACK;
						   			return 1;
						   			break;
						   	  default:
						   	  		break;
						  }

					      EXEC SQL CLOSE c1;
                          EMB_SQL_CHECK("CLOSE CURSOR");

                          break;


				      // Add entry
				      case 1:
				          account[0] = '\0';
						  userid[0] = '\0';
						  password[0] = '\0';
						  description[0] = '\0';
						  fflush(stdin);

						  printf( "\nAccount    : " ); fscanf( stdin, "%s", account );
						  if( strlen( account ) == 0 )
						     break;
						  printf( "Userid     : " ); fscanf( stdin, "%s", userid );
						  printf( "Password   : " ); fscanf( stdin, "%s", password );
   						  printf( "Description: " ); fscanf( stdin, "%s", description );

   						  // read description as sentence

   						  EXEC SQL INSERT INTO pwdsafe.pwdlist (account,userid,password,description,usr,ts) values
   						      (:account, :userid, encrypt(:password, :enc_pwd), :description, :user, current timestamp);

   						  // -803 duplicate rows - constraint violation

   						  if( sqlca.sqlcode == -803 )
						  {
						  	  printf( "\nAccount already exists.\n" );
						  	  EXEC SQL ROLLBACK;
						  	  break;
						  }
						  else {
						  	  EMB_SQL_CHECK("INSERT");
						  	  EXEC SQL COMMIT;
						  }

				          break;

				      // Update Entry
				      case 4:
				          printf( "\nWhich account: " );
						  acc[0] = '\0';
						  fflush(stdin);
						  fscanf( stdin, "%s", acc );

						  EXEC SQL DECLARE c5 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description
						             FROM pwdsafe.pwdlist
						          WHERE usr = :user AND ucase(account) LIKE ucase('%' concat :acc concat '%')
						          FOR UPDATE;

						  EXEC SQL OPEN c5;
						  EMB_SQL_CHECK("OPEN CURSOR");

                          i=0;

						  do {
						      account[0] = '\0';
							  userid[0] = '\0';
							  password[0] = '\0';
						      description[0] = '\0';

						      haccount[0] = '\0';
							  huserid[0] = '\0';
							  hpassword[0] = '\0';
							  hdescription[0] = '\0';

							  fflush(stdin);

						      EXEC SQL FETCH c5 INTO :account, :userid, :password, :description;
						      if (SQLCODE != 0) break;

						      do {
							  printf( "\n1. Account    : %s", account );
							  printf( "\n2. Userid     : %s", userid );
							  printf( "\n3. Password   : %s", password );
							  printf( "\n4. Description: %s", description );
   						 	  printf( "\n" );

						      printf( "Update? (1/2/3/4/n) Main Menue (q)" );
						      upd = 0;
						      fscanf( stdin, "%c", &upd );

						      fflush(stdin);

						      switch( upd )
						      {
								  case '1':
								     printf( "\nAccount: " ); fscanf( stdin, "%s", haccount );

								     EXEC SQL UPDATE pwdsafe.pwdlist SET account = :haccount, ts = current timestamp
									          WHERE CURRENT OF c5;

									 if( sqlca.sqlcode == -803 )
									    printf( "\nAccount already exists.\n" );

									 strcpy( account, haccount );
									 break;
								  case '2':
								     printf( "\nUserid: " ); fscanf( stdin, "%s", huserid );

								     EXEC SQL UPDATE pwdsafe.pwdlist SET userid = :huserid, ts = current timestamp
									          WHERE CURRENT OF c5;
         							 EMB_SQL_CHECK("UPDATE");

								     strcpy( userid, huserid );
								     break;
								  case '3':
								     printf( "\nPassword: " ); fscanf( stdin, "%s", hpassword );

								     EXEC SQL UPDATE pwdsafe.pwdlist SET password = encrypt(:hpassword, :enc_pwd), ts = current timestamp
									          WHERE CURRENT OF c5;
         							 EMB_SQL_CHECK("UPDATE");

								     strcpy( password, hpassword );
								     break;
								  case '4':
								     printf( "\nDescription: " ); fscanf( stdin, "%s", hdescription );

								     EXEC SQL UPDATE pwdsafe.pwdlist SET description = :hdescription, ts = current timestamp
									          WHERE CURRENT OF c5;
         							 EMB_SQL_CHECK("UPDATE");

								     strcpy( description, hdescription );
								     break;
								  case 'q':
								     goto eloop_upd;
								     break;
								  default:
								     break;
							  }
						      } while ( upd != 'n' );
							  i++;

						  } while ( 1 );

                          switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	     printf( "\nWrong decryption password.");
						  		 EXEC SQL ROLLBACK;
						     	 return 1;
						  		 break;
						  	  case -803:
						  	     printf( "\nAccount already exists.\n" );
								 EXEC SQL ROLLBACK;
								 break;
						  	  case 100:
						       	 if( i == 0 )
						       	    printf( "\nAccount not found." );
						   		 break;
						   	  default:
						   		 break;
						  }

						  eloop_upd:

						  EXEC SQL CLOSE c5;
						  EMB_SQL_CHECK("CLOSE CURSOR");

						  EXEC SQL COMMIT;
						  EMB_SQL_CHECK("COMMIT");

				          break;

				      // Delete Entry
				      case 5:
				          printf( "\nWhich account: " );
						  acc[0] = '\0';
						  fflush(stdin);
						  fscanf( stdin, "%s", acc );

						  EXEC SQL DECLARE c4 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description
						             FROM pwdsafe.pwdlist
						          WHERE usr = :user AND ucase(account) LIKE ucase('%' concat :acc concat '%')
						          FOR UPDATE;

						  EXEC SQL OPEN c4;
						  EMB_SQL_CHECK("OPEN CURSOR");

                          i=0;

						  do {
						      account[0] = '\0';
							  userid[0] = '\0';
							  password[0] = '\0';
						      description[0] = '\0';

						      EXEC SQL FETCH c4 INTO :account, :userid, :password, :description;
						      if (SQLCODE != 0) break;

						      printf( "\nAccount    : %s", account );
							  printf( "\nUserid     : %s", userid );
							  printf( "\nPassword   : %s", password );
							  printf( "\nDescription: %s", description );
   						 	  printf( "\n" );

						      printf( "Delete? (y/n) Main Menue (q)" );
						      del = 0;
						      fflush(stdin);
						      fscanf( stdin, "%c", &del );

						      switch( del )
						      {
								  case 'y':
								     EXEC SQL DELETE FROM pwdsafe.pwdlist WHERE CURRENT OF c4;
						             EMB_SQL_CHECK("DELETE");
								     break;
								  case 'q':
								     goto eloop_del;
								     break;
								  default:
								     break;
							  }
							  i++;

						  } while ( 1 );

                          switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	     printf( "\nWrong decryption password.");
						  		 EXEC SQL ROLLBACK;
						     	 return 1;
						  		 break;
						  	  case 100:
						       	 if( i == 0 )
						       	    printf( "\nAccount not found." );
						   		 break;
						   	  default:
						   		 break;
						  }

						  eloop_del:

						  EXEC SQL CLOSE c4;
						  EMB_SQL_CHECK("CLOSE CURSOR");

						  EXEC SQL COMMIT;
						  EMB_SQL_CHECK("COMMIT");

				          break;

				      // Register new user
				      case 12:
					  	  reguser[0] = '\0';
					  	  regpwd[0] = '\0';

					      printf( "\nUser    : " ); fscanf( stdin, "%s", reguser );
					  	  printf( "Pwd     : " ); fscanf( stdin, "%s", regpwd );

					  	  if(strlen(regpwd) < 6)
					  	  {
							  printf( "\n\nPassword has to be at least 6 bytes.\n" );
							  break;
						  }

					  	  temp_pwd = php_md5( regpwd );
						  enc_pwd2[0] = '\0';
						  strcpy( enc_pwd2, temp_pwd );
                          free( temp_pwd );

					      EXEC SQL INSERT INTO pwdsafe.pwdlogin (usr,pwd) values
					           (:reguser, :enc_pwd2);

					      // -803 duplicate rows - constraint violation

					      if( sqlca.sqlcode == -803 )
					      {
							  printf( "\nUser already exists.\n" );
							  EXEC SQL ROLLBACK;
							  break;
						  }
						  else {
							  EMB_SQL_CHECK("INSERT");
							  EXEC SQL COMMIT;
						  }

   						  break;

                      // print to csv file
                      case 7:
                          printf( "\nEnter [path]filename: " );
						  filename[0] = '\0';
						  fflush(stdin);
						  fscanf( stdin, "%s", filename );

                          if( strlen( filename ) == 0 )
                             fp = fopen( "pwdfile.csv", "w" );
						  else
                             fp = fopen( filename, "w" );

                          EXEC SQL DECLARE c6 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description, ts
						              FROM pwdsafe.pwdlist
						          WHERE usr = :user
						          ORDER BY account;

						  EXEC SQL OPEN c6;
					      EMB_SQL_CHECK("OPEN CURSOR");

					      do {
					         EXEC SQL FETCH c6 INTO :account, :userid, :password, :description, :ts INDICATOR :tsind;

					         if (SQLCODE != 0) break;

					         fprintf( fp, "\"%s\",", account );
							 fprintf( fp, "\"%s\",", userid );
							 fprintf( fp, "\"%s\",", password );
   						 	 fprintf( fp, "\"%s\"", description );
   						 	 if( tsind >= 0 )
   						 	    fprintf( fp, ",\"%s\"", ts );
   						 	 fprintf( fp, "\n" );
					      } while ( 1 );


					      switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	  		printf( "\nWrong decryption password.");
						   			EXEC SQL ROLLBACK;
						   			return 1;
						   			break;
						   	  default:
						   	  		break;
						  }

					      EXEC SQL CLOSE c6;
                          EMB_SQL_CHECK("CLOSE CURSOR");

					      fclose( fp );

                          break;


                      // print to file
                      case 8:
                          printf( "\nEnter [path]filename: " );
						  filename[0] = '\0';
						  fflush(stdin);
						  fscanf( stdin, "%s", filename );

                          if( strlen( filename ) == 0 )
                             fp = fopen( "pwdfile.txt", "w" );
						  else
                             fp = fopen( filename, "w" );

                          EXEC SQL DECLARE c7 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description
						              FROM pwdsafe.pwdlist
						          WHERE usr = :user
						          ORDER BY account;

						  EXEC SQL OPEN c7;
					      EMB_SQL_CHECK("OPEN CURSOR");

					      do {
					         EXEC SQL FETCH c7 INTO :account, :userid, :password, :description;

					         if (SQLCODE != 0) break;

					         fprintf( fp, "\nAccount    : %s", account );
							 fprintf( fp, "\nUserid     : %s", userid );
							 fprintf( fp, "\nPassword   : %s", password );
   						 	 fprintf( fp, "\nDescription: %s", description );
   						 	 fprintf( fp, "\n" );
					      } while ( 1 );


					      switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	  		printf( "\nWrong decryption password.");
						   			EXEC SQL ROLLBACK;
						   			return 1;
						   			break;
						   	  default:
						   	  		break;
						  }

					      EXEC SQL CLOSE c7;
                          EMB_SQL_CHECK("CLOSE CURSOR");

					      fclose( fp );

                          break;

					  // Change login password
				      case 9:
					  	  regpwd[0] = '\0';

					      printf( "\nNew password: " ); fscanf( stdin, "%s", regpwd );

					  	  if(strlen(regpwd) < 6)
					  	  {
							  printf( "\n\nPassword has to be at least 6 bytes.\n" );
							  break;
						  }

					  	  temp_pwd = php_md5( regpwd );
						  enc_pwd2[0] = '\0';
						  strcpy( enc_pwd2, temp_pwd );
                          free( temp_pwd );

					      EXEC SQL BEGIN COMPOUND ATOMIC STATIC
					         UPDATE pwdsafe.pwdlist
					            SET password = encrypt( decrypt_char( password, :enc_pwd ), :regpwd )
					         WHERE usr = :user;

					         UPDATE pwdsafe.pwdlogin
					            SET pwd = :enc_pwd2
					         WHERE usr = :user;

						     COMMIT ;
						  END COMPOUND ;

					      if( sqlca.sqlcode == 0 )
					      {
							  enc_pwd[0] = '\0';
							  strcpy( enc_pwd, regpwd );
						  }

					      break;

					  // Export for sync
					  case 10:
                          printf( "\nEnter [path]filename: " );
						  filename[0] = '\0';
						  fflush(stdin);
						  fscanf( stdin, "%s", filename );

                          // Export Data

                          DataExport( filename, user );

						  break;


					  // Import and sync
					  case 11:

					      EXEC SQL CREATE TABLE "PWDSAFE"."TPWDLIST" LIKE pwdsafe.pwdlist;

					      if( sqlca.sqlcode == -601 )
					      {
							  printf( "\nTable already exists.\n" );
							  //EXEC SQL DELETE FROM "PWDSAFE"."TPWDLIST";
							  EXEC SQL COMMIT;
						  }

                          /*
                          printf( "\nEnter [path]filename: " );
						  filename[0] = '\0';
						  fflush(stdin);
						  fscanf( stdin, "%s", filename );
						  */

                          // Import Data

                          //DataImport( filename );

						  break;

				      default:
				          printf("\nError in Reset... should not happen... exiting...\n");
				          exit(99);
				          break;
                   }  /* switch numsel */

            } /* if */

   } while (numsel != 0);


   EXEC SQL CONNECT RESET;
   EMB_SQL_CHECK("CONNECT RESET");
   return 0;
}

int DataExport(char *dataFileName, char *user)
{
  int rc = 0;
  struct sqlca sqlca = {0};
  struct sqldcol dataDescriptor = {0};
  char actionString[256];
  struct sqllob *pAction = {0};
  char msgFileName[255];
  struct db2ExportOut outputInfo = {0};
  struct db2ExportStruct exportParmStruct = {0};

  /* export data */
  dataDescriptor.dcolmeth = SQL_METH_D;
  sprintf( actionString, "SELECT * FROM pwdsafe.pwdlist where usr = '%s'", user );
  pAction = (struct sqllob *)malloc(sizeof(sqluint32) +
                                     sizeof(actionString) + 1);
  pAction->length = strlen(actionString);
  strcpy(pAction->data, actionString);
  strcpy(msgFileName, "tbexport.MSG");

  exportParmStruct.piDataFileName    = dataFileName;
  exportParmStruct.piLobPathList     = NULL;
  exportParmStruct.piLobFileList     = NULL;
  exportParmStruct.piDataDescriptor  = &dataDescriptor;
  exportParmStruct.piActionString    = pAction;
  exportParmStruct.piFileType        = SQL_IXF;
  exportParmStruct.piFileTypeMod     = NULL;
#ifdef WIN32
  exportParmStruct.piMsgFileName     = msgFileName;
#else
  exportParmStruct.piMsgFileName     = "/dev/null";
#endif
  exportParmStruct.iCallerAction     = SQLU_INITIAL;
  exportParmStruct.poExportInfoOut   = &outputInfo;

  /* export data */
  db2Export(db2Version820,
            &exportParmStruct,
            &sqlca);

  /* free memory allocated */
  free(pAction);

 /* display import info */
  printf("\n   Export info.\n");
  printf("      rows exported : %ld\n", (int)outputInfo.oRowsExported);

  return 0;
} /* DataExport */

int DataImport(char *dataFileName)
{
  int rc = 0;
  struct sqlca sqlca = {0};
  struct sqldcol dataDescriptor = {0};
  char actionString[256];
  struct sqlchar *pAction = {0};
  char msgFileName[255];
  struct db2ImportIn inputInfo = {0};
  struct db2ImportOut outputInfo = {0};
  struct db2ImportStruct importParmStruct = {0};
  //int commitcount = 10;

  /* import table */
  dataDescriptor.dcolmeth = SQL_METH_D;
  strcpy(actionString, "INSERT INTO pwdsafe.tpwdlist");
  pAction = (struct sqlchar *)malloc(sizeof(short) +
                                     sizeof(actionString) + 1);
  pAction->length = strlen(actionString);
  strcpy(pAction->data, actionString);
  strcpy(msgFileName, "tbimport.MSG");

  /* Setup db2ImportIn structure */
  inputInfo.iRowcount = inputInfo.iRestartcount = 0;
  inputInfo.iSkipcount = inputInfo.iWarningcount = 0;
  inputInfo.iNoTimeout = 0;
  inputInfo.iAccessLevel = SQLU_ALLOW_NO_ACCESS;
  //inputInfo.piCommitcount = &commitcount;

  importParmStruct.piDataFileName    = dataFileName;
  importParmStruct.piLobPathList     = NULL;
  importParmStruct.piDataDescriptor  = &dataDescriptor;
  importParmStruct.piActionString    = pAction;
  importParmStruct.piFileType        = SQL_IXF;
  importParmStruct.piFileTypeMod     = NULL;
#ifdef WIN32
  importParmStruct.piMsgFileName     = msgFileName;
#else
  importParmStruct.piMsgFileName     = "/dev/null";
#endif
  importParmStruct.piImportInfoIn    = &inputInfo;
  importParmStruct.poImportInfoOut   = &outputInfo;
  importParmStruct.piNullIndicators  = NULL;
  importParmStruct.iCallerAction     = SQLU_INITIAL;

  /* import table */
  db2Import(db2Version820,
            &importParmStruct,
            &sqlca);

  /* free memory allocated */
  free(pAction);

 /* display import info */
  printf("\n   Import info.\n");
  printf("      rows read     : %ld\n", (int)outputInfo.oRowsRead);
  printf("      rows inserted : %ld\n", (int)outputInfo.oRowsInserted);
  printf("      rows rejected : %ld\n", (int)outputInfo.oRowsRejected);
  printf("      rows committed: %ld\n", (int)outputInfo.oRowsCommitted);

  return 0;
} /* DataImport */
