/*
 * $Id$
 */

#ifdef LINUX
#include <termios.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include <sqlenv.h>
#include <sqlutil.h>
#include <db2ApiDf.h>
#include <malloc.h>
#ifdef WIN32
#include <conio.h>
#endif
#include <ctype.h>
#include "utilemb.h"
#include "php_md5.h"

#define	RELEASE	"1.5"
#define REVISION "$Revision$"

#define MAX_ACC_LEN		32
#define MAX_UID_LEN		32
#define MAX_PWD_LEN		32
#define MAX_DESC_LEN	64

#define MAX_PATH_LEN	255

int DataExport(char *, char *);
int DataImport(char *);
char* getstr( int len );

EXEC SQL INCLUDE SQLCA;

int main(int argc, char *argv[]) {


   EXEC SQL BEGIN DECLARE SECTION;
           char reguser[32];
           char regpwd[32];
           char user[32];			// var for actual user
           char pwd[34];			// host var for hashed pwd in pwdsafe.pwdlogin
           short admin;				// host var, if user is admin -> allow register new users
           short there;				// host var to check if tables are there
           char account[32];
           char userid[32];
           char password[32];
           char description[64];
           char haccount[32];
		   char huserid[32];
		   char hpassword[32];
           char hdescription[64];
           char enc_pwd[32];		// pwd entered
           char enc_pwd2[33];		// md5 hashed pwd
           char acc[32];			// host var for where clause
           char ts[32];
           short int tsind;			// indicator var for ts
           short int recind[2];		// indicator var for password and description


           char uid[9];				// connection vars
           char passwd[19];
           char db[19];


   EXEC SQL END DECLARE SECTION;

#ifdef LINUX
   struct termios initialrsettings, newrsettings;
#endif

   int maxsel, numsel = 0;			// menue var;
   char numselh[5];					// menue help var
   struct sqlca sqlca;				// sqlca structure
   int ch, i = 0;					// vars for enc_pwd input
   char *temp_pwd;					// temp var for php_md5 func
   char del[5], upd[5], tmp[5];    	// delete and update var (y/n)
   FILE *fp;						// filepointer fp
   char filename[MAX_PATH_LEN];		// var for filename
   char prompt, preview;
   int sync = 0;
   int rc = 0;

   // init connection vars

   db[0] = '\0';
   uid[0] = '\0';
   passwd[0] = '\0';

   switch( argc )
   {
	   case 2:
	      strcpy (db, argv[1]);
	      EXEC SQL CONNECT TO :db;
	      EMB_SQL_CHECK("CONNECT TO DB");
	      break;
	   case 4:
	      strcpy (db, argv[1]);
		  strcpy (uid, argv[2]);
		  strcpy (passwd, argv[3]);
		  EXEC SQL CONNECT TO :db USER :uid USING :passwd;
          EMB_SQL_CHECK("CONNECT TO DB");
          break;
       default:
          printf ("\nUSAGE: %s database [userid passwd]\n\n", argv[0]);
          return 1;
          break;
   }

   user[0] = '\0';
   pwd[0] = '\0';

   printf( "\nUser: ");
   strcpy( user, getstr(MAX_UID_LEN) );
   printf( "\nPlease enter the encryption password: " );

#ifdef WIN32
   do
      {
         ch = _getch();
         switch( ch )
         {
   		     case 8:
   		        if( i != 0 )
   		        {
   		    	   i=i-1;
   		    	   printf( "d" );
   		    	}
   		        break;
   		     case 13:
   		        break;
   		     default:
   		        enc_pwd[i++] = ch;
   		        printf( "*" );
   		        break;
   	     }
      } while( ch != '\r' );

   enc_pwd[i] = '\0';
#endif

#ifdef LINUX
   enc_pwd[0] = '\0';
   tcgetattr( fileno(stdin), &initialrsettings );
   newrsettings = initialrsettings;
   newrsettings.c_lflag &= ~ECHO;
   tcsetattr( fileno(stdin), TCSAFLUSH, &newrsettings );
   strcpy( enc_pwd, getstr(MAX_PWD_LEN) );
   tcsetattr( fileno(stdin), TCSANOW, &initialrsettings );
#endif

   temp_pwd = php_md5( enc_pwd );
   enc_pwd2[0] = '\0';
   strcpy( enc_pwd2, temp_pwd );
   free( temp_pwd );

   EXEC SQL SELECT pwd, admin INTO :pwd, :admin
       FROM pwdsafe.pwdlogin
       WHERE usr = :user;

   if( sqlca.sqlcode == 100 )
   {
	   printf( "\n\nUser not found.\n" );
	   EXEC SQL CONNECT RESET;
       EMB_SQL_CHECK("CONNECT RESET");
	   return 1;
   }
   EMB_SQL_CHECK("SELECT");


   if( strcmp( pwd, enc_pwd2 ) != 0)
   {
	   printf( "\n\nUser / Password do not match.\n" );
	   EXEC SQL CONNECT RESET;
       EMB_SQL_CHECK("CONNECT RESET");
	   return 1;
   }

   printf("\n\n");
   printf("PwdSafe Application v%s (%s)\n",RELEASE,REVISION);

   do
      {
         numsel = 0;
         printf("\n\n");
         printf("************************************\n");
         printf(" 1 - Add entry\n");
         printf(" 2 - Search (fuzzy)\n");
         printf(" 3 - Search (exact)\n");
         printf(" 4 - Update Entry\n");
         printf(" 5 - Delete Entry\n");
         printf(" 6 - List all entries\n");
         printf(" 7 - Print all entries to .csv file\n" );
         printf(" 8 - Print all entries to file\n" );
         printf(" 9 - Change login password\n" );
         printf("10 - Export for sync\n" );
         printf("11 - Import and sync\n" );
         if( admin > 0 )
         {
            printf("12 - Register new user\n" );
         }
         printf("\n   Enter x to exit.\n");
         printf("************************************\n");

         printf("==> ");

         fflush(stdin);

         strcpy( numselh, getstr(5) );

         numsel = atoi( numselh );
         if( numsel == 0 )
            numsel = -1;

         if( numselh[0] == 'x' )
            numsel = 0;

         maxsel = 11;			// Max menue sections
         if( admin > 0 )
         {
			 maxsel++;
		 }
         if (numsel < 0 || numsel > maxsel)
            printf("\nInvalid selection. Please try again.\n");
         else
            if (numsel != 0)
            {
                switch (numsel)
				   {
				      // Search (exact)
				      case 3:
				          printf( "\nWhich account: " );
				          acc[0] = '\0';

						  strcpy( acc, getstr(MAX_ACC_LEN) );

						  if( strlen( acc ) == 0 )
						     break;

						  account[0] = '\0';
						  userid[0] = '\0';
						  password[0] = '\0';
						  description[0] = '\0';

						  EXEC SQL SELECT account, userid, decrypt_char(password, :enc_pwd), description INTO :account, :userid, :password, :description
						              FROM pwdsafe.pwdlist
						              WHERE account = :acc AND usr = :user;

						  switch( sqlca.sqlcode )
						  {
							  case 0:
							   		printf( "\nAccount    : %s", account );
						  			printf( "\nUserid     : %s", userid );
						  			printf( "\nPassword   : %s", password );
   						 			printf( "\nDescription: %s", description );
   						 			break;
   						 	  case 100:
   						 	  		printf( "\nAccount not found." );
   						 	  		break;
   						 	  case -20144:
   						 	  case -20145:
   						 	  		printf( "\nWrong decryption password.");
   						 			EXEC SQL ROLLBACK;
   						 			return 1;
   						 			break;
   						 	  default:
   						 	  		EMB_SQL_CHECK("SELECT statement");
   						 	  		break;
						  }

   						  break;


					  // Search (fuzzy)
					  case 2:
					      printf( "\nWhich account: " );
					      acc[0] = '\0';
					      fflush(stdin);

					      strcpy( acc, getstr(MAX_ACC_LEN) );

						  if( strlen( acc ) == 0 )
						     break;

						  account[0] = '\0';
						  userid[0] = '\0';
						  password[0] = '\0';
						  description[0] = '\0';


						  EXEC SQL DECLARE c2 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description
						              FROM pwdsafe.pwdlist
						          WHERE usr = :user AND ucase(account) LIKE ucase('%' concat :acc concat '%')
						          ORDER BY account;

						  EXEC SQL OPEN c2;
					      EMB_SQL_CHECK("OPEN CURSOR");

					      i=0;

					      do {
					         EXEC SQL FETCH c2 INTO :account, :userid, :password, :description;

					         if (SQLCODE != 0) break;

					         printf( "\nAccount    : %s", account );
							 printf( "\nUserid     : %s", userid );
							 printf( "\nPassword   : %s", password );
   						 	 printf( "\nDescription: %s", description );
   						 	 printf( "\n" );
   						 	 i++;
					      } while ( 1 );


					      switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	  		printf( "\nWrong decryption password.");
						   			EXEC SQL ROLLBACK;
						   			return 1;
						   			break;
						   	  case 100:
							     	if( i == 0 )
							     	    printf( "\nAccount not found." );
   						 	  		break;
						   	  default:
						   	  		break;
						  }

					      EXEC SQL CLOSE c2;
                          EMB_SQL_CHECK("CLOSE CURSOR");

                          break;


   					  // List all entries
   					  case 6:
   					      EXEC SQL DECLARE c1 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description
						              FROM pwdsafe.pwdlist
						          WHERE usr = :user
						          ORDER BY account;

						  EXEC SQL OPEN c1;
					      EMB_SQL_CHECK("OPEN CURSOR");

					      do {
					         EXEC SQL FETCH c1 INTO :account, :userid, :password, :description;

					         if (SQLCODE != 0) break;

					         printf( "\nAccount    : %s", account );
							 printf( "\nUserid     : %s", userid );
							 printf( "\nPassword   : %s", password );
   						 	 printf( "\nDescription: %s", description );
   						 	 printf( "\n" );
					      } while ( 1 );


					      switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	  		printf( "\nWrong decryption password.");
						   			EXEC SQL ROLLBACK;
						   			return 1;
						   			break;
						   	  default:
						   	  		break;
						  }

					      EXEC SQL CLOSE c1;
                          EMB_SQL_CHECK("CLOSE CURSOR");

                          break;


				      // Add entry
				      case 1:
				          account[0] = '\0';
						  userid[0] = '\0';
						  password[0] = '\0';
						  description[0] = '\0';
						  fflush(stdin);

						  printf( "\nAccount    : " ); strcpy( account, getstr(MAX_ACC_LEN) );
						  if( strlen( account ) == 0 )
						     break;
						  printf( "Userid     : " ); strcpy( userid, getstr(MAX_UID_LEN) );
						  printf( "Password   : " ); strcpy( password, getstr(MAX_PWD_LEN) );
   						  printf( "Description: " ); strcpy( description, getstr(MAX_DESC_LEN) );

   						  // read description as sentence

   						  EXEC SQL INSERT INTO pwdsafe.pwdlist (account,userid,password,description,usr,ts) values
   						      (:account, :userid, encrypt(:password, :enc_pwd), :description, :user, current timestamp);

   						  // -803 duplicate rows - constraint violation

   						  if( sqlca.sqlcode == -803 )
						  {
						  	  printf( "\nAccount already exists.\n" );
						  	  EXEC SQL ROLLBACK;
						  	  break;
						  }
						  else {
						  	  EMB_SQL_CHECK("INSERT");
						  	  EXEC SQL COMMIT;
						  }

				          break;

				      // Update Entry
				      case 4:
				          printf( "\nWhich account: " );
						  acc[0] = '\0';
						  fflush(stdin);

						  strcpy( acc, getstr(MAX_ACC_LEN) );

						  if( strlen( acc ) == 0 )
						     break;

						  EXEC SQL DECLARE c5 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description
						             FROM pwdsafe.pwdlist
						          WHERE usr = :user AND ucase(account) LIKE ucase('%' concat :acc concat '%')
						          FOR UPDATE;

						  EXEC SQL OPEN c5;
						  EMB_SQL_CHECK("OPEN CURSOR");

                          i=0;

						  do {
						      account[0] = '\0';
							  userid[0] = '\0';
							  password[0] = '\0';
						      description[0] = '\0';

						      haccount[0] = '\0';
							  huserid[0] = '\0';
							  hpassword[0] = '\0';
							  hdescription[0] = '\0';

							  fflush(stdin);

						      EXEC SQL FETCH c5 INTO :account, :userid, :password, :description;
						      if (SQLCODE != 0) break;

						      do {
							  printf( "\n1. Account    : %s", account );
							  printf( "\n2. Userid     : %s", userid );
							  printf( "\n3. Password   : %s", password );
							  printf( "\n4. Description: %s", description );
   						 	  printf( "\n" );

						      printf( "\n Update? (1/2/3/4/N) Main Menue (q)" );

						      upd[0] = '\0';

						      fflush(stdin);
						      strcpy( upd, getstr(5) );

						      switch( upd[0] )
						      {
								  case '1':
								     printf( "\nAccount: " ); strcpy( haccount, getstr(MAX_ACC_LEN) );

								     EXEC SQL UPDATE pwdsafe.pwdlist SET account = :haccount, ts = current timestamp
									          WHERE CURRENT OF c5;

									 if( sqlca.sqlcode == -803 )
									 {
										 printf( "\nAccount already exists.\n" );
									 } else {
										 strcpy( account, haccount );
									 }
									 break;
								  case '2':
								     printf( "\nUserid: " ); strcpy( huserid, getstr(MAX_UID_LEN) );

								     EXEC SQL UPDATE pwdsafe.pwdlist SET userid = :huserid, ts = current timestamp
									          WHERE CURRENT OF c5;
         							 EMB_SQL_CHECK("UPDATE");

								     strcpy( userid, huserid );
								     break;
								  case '3':
								     printf( "\nPassword: " ); strcpy( hpassword, getstr(MAX_PWD_LEN) );

								     EXEC SQL UPDATE pwdsafe.pwdlist SET password = encrypt(:hpassword, :enc_pwd), ts = current timestamp
									          WHERE CURRENT OF c5;
         							 EMB_SQL_CHECK("UPDATE");

								     strcpy( password, hpassword );
								     break;
								  case '4':
								     printf( "\nDescription: " ); strcpy( hdescription, getstr(MAX_DESC_LEN) );

								     EXEC SQL UPDATE pwdsafe.pwdlist SET description = :hdescription, ts = current timestamp
									          WHERE CURRENT OF c5;
         							 EMB_SQL_CHECK("UPDATE");

								     strcpy( description, hdescription );
								     break;
								  case 'q':
								     goto eloop_upd;
								     break;
								  default:
								     upd[0] = 'n';
								     break;
							  }
						      } while ( upd[0] != 'n' );
							  i++;

						  } while ( 1 );

                          switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	     printf( "\nWrong decryption password.");
						  		 EXEC SQL ROLLBACK;
						     	 return 1;
						  		 break;
						  	  case -803:
						  	     printf( "\nAccount already exists.\n" );
								 EXEC SQL ROLLBACK;
								 break;
						  	  case 100:
						       	 if( i == 0 )
						       	    printf( "\nAccount not found." );
						   		 break;
						   	  default:
						   		 break;
						  }

						  eloop_upd:

						  EXEC SQL CLOSE c5;
						  EMB_SQL_CHECK("CLOSE CURSOR");

						  EXEC SQL COMMIT;
						  EMB_SQL_CHECK("COMMIT");

				          break;

				      // Delete Entry
				      case 5:
				          printf( "\nWhich account: " );
						  acc[0] = '\0';
						  fflush(stdin);

						  strcpy( acc, getstr(MAX_ACC_LEN) );

						  if( strlen( acc ) == 0 )
						     break;

						  EXEC SQL DECLARE c4 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description
						             FROM pwdsafe.pwdlist
						          WHERE usr = :user AND ucase(account) LIKE ucase('%' concat :acc concat '%')
						          FOR UPDATE;

						  EXEC SQL OPEN c4;
						  EMB_SQL_CHECK("OPEN CURSOR");

                          i=0;

						  do {
						      account[0] = '\0';
							  userid[0] = '\0';
							  password[0] = '\0';
						      description[0] = '\0';

						      EXEC SQL FETCH c4 INTO :account, :userid, :password, :description;
						      if (SQLCODE != 0) break;

						      printf( "\nAccount    : %s", account );
							  printf( "\nUserid     : %s", userid );
							  printf( "\nPassword   : %s", password );
							  printf( "\nDescription: %s", description );
   						 	  printf( "\n" );

						      printf( "\n Delete? (y/N) Main Menue (q)" );

						      del[0] = '\0';

						      fflush(stdin);
						      strcpy( del, getstr(5) );

						      switch( del[0] )
						      {
								  case 'y':
								     EXEC SQL DELETE FROM pwdsafe.pwdlist WHERE CURRENT OF c4;
						             EMB_SQL_CHECK("DELETE");
								     break;
								  case 'q':
								     goto eloop_del;
								     break;
								  default:
								     break;
							  }
							  i++;

						  } while ( 1 );

                          switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	     printf( "\nWrong decryption password.");
						  		 EXEC SQL ROLLBACK;
						     	 return 1;
						  		 break;
						  	  case 100:
						       	 if( i == 0 )
						       	    printf( "\nAccount not found." );
						   		 break;
						   	  default:
						   		 break;
						  }

						  eloop_del:

						  EXEC SQL CLOSE c4;
						  EMB_SQL_CHECK("CLOSE CURSOR");

						  EXEC SQL COMMIT;
						  EMB_SQL_CHECK("COMMIT");

				          break;

				      // Register new user
				      case 12:
					  	  reguser[0] = '\0';
					  	  regpwd[0] = '\0';

					      printf( "\nUser    : " ); strcpy( reguser, getstr(MAX_UID_LEN) );
					  	  printf( "Pwd     : " ); strcpy( regpwd, getstr(MAX_PWD_LEN) );

					  	  if(strlen(regpwd) < 6)
					  	  {
							  printf( "\n\nPassword has to be at least 6 bytes.\n" );
							  break;
						  }

					  	  temp_pwd = php_md5( regpwd );
						  enc_pwd2[0] = '\0';
						  strcpy( enc_pwd2, temp_pwd );
                          free( temp_pwd );

					      EXEC SQL INSERT INTO pwdsafe.pwdlogin (usr,pwd) values
					           (:reguser, :enc_pwd2);

					      // -803 duplicate rows - constraint violation

					      if( sqlca.sqlcode == -803 )
					      {
							  printf( "\nUser already exists.\n" );
							  EXEC SQL ROLLBACK;
							  break;
						  }
						  else {
							  EMB_SQL_CHECK("INSERT");
							  EXEC SQL COMMIT;
						  }

   						  break;

                      // print to csv file
                      case 7:
                          printf( "\nEnter [path]filename: " );
						  filename[0] = '\0';

						  fflush(stdin);
						  strcpy( filename, getstr(MAX_PATH_LEN) );

                          if( strlen( filename ) == 0 )
                             break; //fp = fopen( "pwdfile.csv", "w" );
						  else
                             fp = fopen( filename, "w" );

                          if( fp == NULL )
                          {
							  printf( "\n\n Error: Cannot write to file %s\n", filename );
							  break;
						  }

                          EXEC SQL DECLARE c6 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description, ts
						              FROM pwdsafe.pwdlist
						          WHERE usr = :user
						          ORDER BY account;

						  EXEC SQL OPEN c6;
					      EMB_SQL_CHECK("OPEN CURSOR");

					      do {
					         EXEC SQL FETCH c6 INTO :account, :userid, :password, :description, :ts INDICATOR :tsind;

					         if (SQLCODE != 0) break;

					         fprintf( fp, "\"%s\",", account );
							 fprintf( fp, "\"%s\",", userid );
							 fprintf( fp, "\"%s\",", password );
   						 	 fprintf( fp, "\"%s\"", description );
   						 	 if( tsind >= 0 )
   						 	    fprintf( fp, ",\"%s\"", ts );
   						 	 fprintf( fp, "\n" );
					      } while ( 1 );


					      switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	  		printf( "\nWrong decryption password.");
						   			EXEC SQL ROLLBACK;
						   			return 1;
						   			break;
						   	  default:
						   	  		break;
						  }

					      EXEC SQL CLOSE c6;
                          EMB_SQL_CHECK("CLOSE CURSOR");

					      fclose( fp );

                          break;


                      // print to file
                      case 8:
                          printf( "\nEnter [path]filename: " );
						  filename[0] = '\0';

						  fflush(stdin);
						  strcpy( filename, getstr(MAX_PATH_LEN) );

                          if( strlen( filename ) == 0 )
                             break; //fp = fopen( "pwdfile.txt", "w" );
						  else
                             fp = fopen( filename, "w" );

                          if( fp == NULL )
                          {
							  printf( "\n\n Error: Cannot write to file %s\n", filename );
							  break;
						  }

                          EXEC SQL DECLARE c7 CURSOR FOR
					              SELECT account, userid, decrypt_char(password, :enc_pwd), description
						              FROM pwdsafe.pwdlist
						          WHERE usr = :user
						          ORDER BY account;

						  EXEC SQL OPEN c7;
					      EMB_SQL_CHECK("OPEN CURSOR");

					      do {
					         EXEC SQL FETCH c7 INTO :account, :userid, :password, :description;

					         if (SQLCODE != 0) break;

					         fprintf( fp, "\nAccount    : %s", account );
							 fprintf( fp, "\nUserid     : %s", userid );
							 fprintf( fp, "\nPassword   : %s", password );
   						 	 fprintf( fp, "\nDescription: %s", description );
   						 	 fprintf( fp, "\n" );
					      } while ( 1 );


					      switch( sqlca.sqlcode )
						  {
						   	  case -20144:
						   	  case -20145:
						   	  		printf( "\nWrong decryption password.");
						   			EXEC SQL ROLLBACK;
						   			return 1;
						   			break;
						   	  default:
						   	  		break;
						  }

					      EXEC SQL CLOSE c7;
                          EMB_SQL_CHECK("CLOSE CURSOR");

					      fclose( fp );

                          break;

					  // Change login password
				      case 9:
					  	  regpwd[0] = '\0';

					      printf( "\nNew password: " ); strcpy( regpwd, getstr(MAX_PWD_LEN) );

					  	  if(strlen(regpwd) < 6)
					  	  {
							  printf( "\n\nPassword has to be at least 6 bytes.\n" );
							  break;
						  }

					  	  temp_pwd = php_md5( regpwd );
						  enc_pwd2[0] = '\0';
						  strcpy( enc_pwd2, temp_pwd );
                          free( temp_pwd );

					      EXEC SQL BEGIN COMPOUND ATOMIC STATIC
					         UPDATE pwdsafe.pwdlist
					            SET password = encrypt( decrypt_char( password, :enc_pwd ), :regpwd )
					         WHERE usr = :user;

					         UPDATE pwdsafe.pwdlogin
					            SET pwd = :enc_pwd2
					         WHERE usr = :user;

						     COMMIT ;
						  END COMPOUND ;

					      if( sqlca.sqlcode == 0 )
					      {
							  enc_pwd[0] = '\0';
							  strcpy( enc_pwd, regpwd );
						  }

					      break;

					  // Export for sync
					  case 10:
					      printf( "\nEnter [path]filename: " );
					      filename[0] = '\0';

						  fflush(stdin);
						  strcpy( filename, getstr(MAX_PATH_LEN) );

						  if( strlen( filename ) == 0 )
						     break;

                          rc = DataExport( filename, user );

                          if( rc != 0 )
                             printf( "\n\n Error: export to file %s\n", filename );

						  break;

					  // Import and sync
					  case 11:
						  printf( "\nEnter [path]filename: " );
						  filename[0] = '\0';

						  fflush(stdin);
						  strcpy( filename, getstr(MAX_PATH_LEN) );

						  if( strlen( filename ) == 0 )
						     break;

					      EXEC SQL CREATE TABLE "PWDSAFE"."TPWDLIST" LIKE "PWDSAFE"."PWDLIST";

					      if( sqlca.sqlcode == -601 )
					      {
							  EXEC SQL DELETE FROM "PWDSAFE"."TPWDLIST";
							  EXEC SQL COMMIT;
						  }

						  rc = DataImport( filename );

						  if( rc != 0 )
						  {
							  printf( "\n\n Error: import from file %s\n", filename );
							  break;
						  }


						  EXEC SQL DECLARE u1 CURSOR FOR
						          SELECT l.account, l.userid, decrypt_char(l.password, :enc_pwd), l.description,
						                 t.account, t.userid, decrypt_char(t.password, :enc_pwd), t.description
						          FROM pwdsafe.pwdlist l, pwdsafe.tpwdlist t
								  WHERE l.account = t.account AND l.usr = t.usr AND
								  l.usr = :user AND
								  (
								  l.ts < t.ts OR
								  l.ts IS NULL
								  ) AND
								  (
								  l.userid != t.userid OR
								  decrypt_char(l.password, :enc_pwd) != decrypt_char(t.password, :enc_pwd) OR
								  l.description != t.description
								  )
								  ORDER BY l.account;

						  EXEC SQL DECLARE u2 CURSOR FOR
						          SELECT t.account, t.userid, decrypt_char(t.password, :enc_pwd), t.description
						          FROM pwdsafe.tpwdlist t
						          WHERE t.usr = :user AND t.account
								  NOT IN (SELECT account FROM pwdsafe.pwdlist l WHERE l.usr = t.usr)
								  ORDER BY t.account;

						  EXEC SQL DECLARE u3 CURSOR FOR
						          SELECT t.account, t.userid, decrypt_char(t.password, :enc_pwd), t.description
						          FROM pwdsafe.pwdlist t
						          WHERE t.usr = :user AND t.account
								  NOT IN (SELECT account FROM pwdsafe.tpwdlist l WHERE l.usr = t.usr)
								  ORDER BY t.account
								  FOR UPDATE;

						  EXEC SQL OPEN u1;
						  EMB_SQL_CHECK("OPEN CURSOR u1");

						  printf( "\n Preview? (y/N)" );

						  tmp[0] = '\0';
						  fflush(stdin);
						  strcpy( tmp, getstr(5) );
						  preview = tmp[0];
						  prompt = 'n';

						  if( preview != 'y' )
						  {
							  printf( "\n Prompt? (Y/n)" );
							  tmp[0] = '\0';
							  fflush(stdin);
							  strcpy( tmp, getstr(5) );
							  prompt = tmp[0];
						  }

						  if( preview != 'y' )
						     preview = 'n';

						  if( prompt != 'n' )
						     prompt = 'y';

						  do {
							  account[0] = '\0';
							  userid[0] = '\0';
							  password[0] = '\0';
							  description[0] = '\0';

							  haccount[0] = '\0';
							  huserid[0] = '\0';
							  hpassword[0] = '\0';
							  hdescription[0] = '\0';

							  EXEC SQL FETCH u1 INTO :account, :userid, :password, :description, :haccount, :huserid, :hpassword, :hdescription;
							  if (SQLCODE != 0) break;

						      printf( "\n------------------------------------" );
						      printf( "\nAccount    : %s", account );
							  printf( "\nUserid     : %s", userid );
							  printf( "\nPassword   : %s", password );
							  printf( "\nDescription: %s", description );
   						 	  printf( "\n  CHANGING TO" );

						      printf( "\nAccount    : %s", haccount );
							  printf( "\nUserid     : %s", huserid );
							  printf( "\nPassword   : %s", hpassword );
							  printf( "\nDescription: %s", hdescription );
   						 	  printf( "\n------------------------------------" );

   						 	  if( preview != 'y' )
   						 	     sync = 1;

   						 	  if( prompt == 'y' )
   						 	  {
								  printf( "\n Sync? (y/N) Main Menue (q)" );

								  upd[0] = '\0';
								  fflush(stdin);
								  strcpy( upd, getstr(5) );

								  if( upd[0] == 'q' )
								     goto eloop_sync;

								  if( upd[0] != 'y' )
								     sync = 0;
							  }

							  if( sync )
							  {
								  EXEC SQL UPDATE pwdsafe.pwdlist SET (userid, password, description, ts) =
								  (:huserid, encrypt(:hpassword, :enc_pwd), :hdescription, current timestamp)
								  WHERE account = :account AND usr = :user;

								  EMB_SQL_CHECK("UPDATE - SYNC");
								  //printf( "\nDEBUG: synced.\n" );
								  printf( "\nDone.\n" );
							  }

						  } while( 1 );

						  eloop_sync:

						  EXEC SQL CLOSE u1;
						  EMB_SQL_CHECK("CLOSE CURSOR u1");

						  if( upd[0] == 'q' )
						     goto eloop_sync4;

						  EXEC SQL OPEN u2;
						  EMB_SQL_CHECK("OPEN CURSOR u2");

						  do {
							  account[0] = '\0';
							  userid[0] = '\0';
							  password[0] = '\0';
							  description[0] = '\0';

							  EXEC SQL FETCH u2 INTO :account, :userid, :password, :description INDICATOR :recind;
							  if (SQLCODE != 0) break;

						      printf( "\n------------------------------------" );
						      printf( "\nAccount    : %s", account );
							  printf( "\nUserid     : %s", userid );
							  printf( "\nPassword   : %s", password );
							  printf( "\nDescription: %s", description );
   						 	  printf( "\n  ADD" );
   						 	  printf( "\n------------------------------------" );

   						 	  if( preview != 'y' )
   						 	     sync = 1;

   						 	  if( prompt == 'y' )
   						 	  {
								  printf( "\n Add? (y/N) Main Menue (q)" );

								  upd[0] = '\0';
								  fflush(stdin);
								  strcpy( upd, getstr(5) );

								  if( upd[0] == 'q' )
								     goto eloop_sync2;

								  if( upd[0] != 'y' )
								     sync = 0;
							  }

							  if( sync )
							  {
								  EXEC SQL INSERT INTO pwdsafe.pwdlist (account,userid,password,description,usr,ts) values
								  (:account, :userid, encrypt(:password, :enc_pwd), :description, :user, current timestamp);

								  EMB_SQL_CHECK("INSERT - SYNC");
								  //printf( "\nDEBUG: added.\n" );
								  printf( "\nDone.\n" );
							  }

						  } while( 1 );

						  eloop_sync2:

						  EXEC SQL CLOSE u2;
						  EMB_SQL_CHECK("CLOSE CURSOR u2");

						  if( upd[0] == 'q' )
						     goto eloop_sync4;

						  EXEC SQL OPEN u3;
						  EMB_SQL_CHECK("OPEN CURSOR u3");

						  do {
							  account[0] = '\0';
							  userid[0] = '\0';
							  password[0] = '\0';
							  description[0] = '\0';

							  EXEC SQL FETCH u3 INTO :account, :userid, :password, :description INDICATOR :recind;
							  if (SQLCODE != 0) break;

						      printf( "\n------------------------------------" );
						      printf( "\nAccount    : %s", account );
							  printf( "\nUserid     : %s", userid );
							  printf( "\nPassword   : %s", password );
							  printf( "\nDescription: %s", description );
   						 	  printf( "\n  DELETE" );
   						 	  printf( "\n------------------------------------" );

   						 	  if( preview != 'y' )
   						 	     sync = 1;

   						 	  if( prompt == 'y' )
   						 	  {
								  printf( "\n Delete? (y/N) Main Menue (q)" );

								  upd[0] = '\0';
								  fflush(stdin);
								  strcpy( upd, getstr(5) );

								  if( upd[0] == 'q' )
								     goto eloop_sync3;

								  if( upd[0] != 'y' )
								     sync = 0;
							  }

							  if( sync )
							  {
								  EXEC SQL DELETE FROM pwdsafe.pwdlist WHERE CURRENT OF u3;

								  EMB_SQL_CHECK("DELETE - SYNC");
								  //printf( "\nDEBUG: deleted.\n" );
								  printf( "\nDone.\n" );
							  }

						  } while( 1 );

						  eloop_sync3:

						  EXEC SQL CLOSE u3;
						  EMB_SQL_CHECK("CLOSE CURSOR u3");

						  eloop_sync4:

						  EXEC SQL COMMIT;

						  EXEC SQL DROP TABLE "PWDSAFE"."TPWDLIST";

						  break;

				      default:
				          printf("\nError in Reset... should not happen... exiting...\n");
				          exit(99);
				          break;
                   }  /* switch numsel */

            } /* if */

   } while (numsel != 0);


   EXEC SQL CONNECT RESET;
   EMB_SQL_CHECK("CONNECT RESET");
   return 0;
}

int DataExport(char *dataFileName, char *user)
{
  int rc = 0;
  struct sqlca sqlca = {0};
  struct sqldcol dataDescriptor = {0};
  char actionString[256];
  struct sqllob *pAction = {0};
  char msgFileName[MAX_PATH_LEN];
  struct db2ExportOut outputInfo = {0};
  struct db2ExportStruct exportParmStruct = {0};

  /* export data */
  dataDescriptor.dcolmeth = SQL_METH_D;
  sprintf( actionString, "SELECT * FROM pwdsafe.pwdlist where usr = '%s'", user );
  pAction = (struct sqllob *)malloc(sizeof(sqluint32) +
                                     sizeof(actionString) + 1);
  pAction->length = strlen(actionString);
  strcpy(pAction->data, actionString);
  strcpy(msgFileName, "tbexport.MSG");

  exportParmStruct.piDataFileName    = dataFileName;
  exportParmStruct.piLobPathList     = NULL;
  exportParmStruct.piLobFileList     = NULL;
  exportParmStruct.piDataDescriptor  = &dataDescriptor;
  exportParmStruct.piActionString    = pAction;
  exportParmStruct.piFileType        = SQL_IXF;
  exportParmStruct.piFileTypeMod     = NULL;
#ifdef WIN32
  exportParmStruct.piMsgFileName     = msgFileName;
#else
  exportParmStruct.piMsgFileName     = "/dev/null";
#endif
  exportParmStruct.iCallerAction     = SQLU_INITIAL;
  exportParmStruct.poExportInfoOut   = &outputInfo;

  /* export data */
  db2Export(db2Version820,
            &exportParmStruct,
            &sqlca);

  /* free memory allocated */
  free(pAction);

  if( (int)outputInfo.oRowsExported == 0 )
     return -1;

 /* display import info */
  printf("\n   Export info.\n");
  printf("      rows exported : %ld\n", (int)outputInfo.oRowsExported);

  return 0;
} /* DataExport */

int DataImport(char *dataFileName)
{
  int rc = 0;
  struct sqlca sqlca = {0};
  struct sqldcol dataDescriptor = {0};
  char actionString[256];
  struct sqlchar *pAction = {0};
  char msgFileName[MAX_PATH_LEN];
  struct db2ImportIn inputInfo = {0};
  struct db2ImportOut outputInfo = {0};
  struct db2ImportStruct importParmStruct = {0};
  //int commitcount = 10;

  /* import table */
  dataDescriptor.dcolmeth = SQL_METH_D;
  strcpy(actionString, "INSERT INTO pwdsafe.tpwdlist");
  pAction = (struct sqlchar *)malloc(sizeof(short) +
                                     sizeof(actionString) + 1);
  pAction->length = strlen(actionString);
  strcpy(pAction->data, actionString);
  strcpy(msgFileName, "tbimport.MSG");

  /* Setup db2ImportIn structure */
  inputInfo.iRowcount = inputInfo.iRestartcount = 0;
  inputInfo.iSkipcount = inputInfo.iWarningcount = 0;
  inputInfo.iNoTimeout = 0;
  inputInfo.iAccessLevel = SQLU_ALLOW_NO_ACCESS;
  //inputInfo.piCommitcount = &commitcount;

  importParmStruct.piDataFileName    = dataFileName;
  importParmStruct.piLobPathList     = NULL;
  importParmStruct.piDataDescriptor  = &dataDescriptor;
  importParmStruct.piActionString    = pAction;
  importParmStruct.piFileType        = SQL_IXF;
  importParmStruct.piFileTypeMod     = NULL;
#ifdef WIN32
  importParmStruct.piMsgFileName     = msgFileName;
#else
  importParmStruct.piMsgFileName     = "/dev/null";
#endif
  importParmStruct.piImportInfoIn    = &inputInfo;
  importParmStruct.poImportInfoOut   = &outputInfo;
  importParmStruct.piNullIndicators  = NULL;
  importParmStruct.iCallerAction     = SQLU_INITIAL;

  /* import table */
  db2Import(db2Version820,
            &importParmStruct,
            &sqlca);

  /* free memory allocated */
  free(pAction);

  if( ((int)outputInfo.oRowsRead != (int)outputInfo.oRowsInserted) || (int)outputInfo.oRowsRead == 0 )
     return -1;

 /* display import info */
  printf("\n   Import info.\n");
  printf("      rows read     : %ld\n", (int)outputInfo.oRowsRead);
  printf("      rows inserted : %ld\n", (int)outputInfo.oRowsInserted);
  printf("      rows rejected : %ld\n", (int)outputInfo.oRowsRejected);
  printf("      rows committed: %ld\n", (int)outputInfo.oRowsCommitted);

  return 0;
} /* DataImport */

char* getstr( int len )
{
	char *result;

	result = (char*)malloc(len*sizeof(char));

	fgets( result, len, stdin );
	result[strlen(result)-1] = '\0';

	return result;
}
